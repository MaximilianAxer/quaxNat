fun <- match.arg(fun,
c("Clark2dt",
"lognormal"))
result <- switch(fun,
Clark2dt = Clark2dt(x, par),
lognormal = lognormal())
return(result)
}
S(y = 1, x = 2, par = 1:3, tau = 0.5, fun = "logn")
S(y = 1, x = 2, par = 1:3, tau = 0.5, fun = "Cl")
S(y = 1, x = 2, par = 1:3, tau = 0.5, fun = "C")
S(y = 1, x = 2, par = 1:3, tau = 0.5, fun = "A")
S.functions <- function(x, par, fun){
fun <- match.arg(fun,
c("Clark2dt",
"lognormal"))
f <- get(fun)
result <- f(x, par)
return(result)
}
S <- function(y, x, par, tau, fun) {         #   where B0 can be replaced with B1, B2
res <- y - S.functions(x, par, fun)
w <- tau - 0.5 + 0.5*sign(res)
sum(x^0 * w * res, na.rm=TRUE)
}
S(y = 1, x = 2, par = 1:3, tau = 0.5, fun = "A")
S(y = 1, x = 2, par = 1:3, tau = 0.5, fun = "C")
fun
#' @param par parameters U, P, N estimated within the Clark2DT function
#' @param x represents the distance to the nearest seed source. Must be numeric
#'
#' @details Mixture of Gaussian nuclei that produces tails that are not quite as long. Maximum at seed tree itself and cannot become 0 at x = 0.
Clark2dt <- function(x, par){
U <- par[1]
P <- par[2]
N <- par[3]
result <- N * ((P)/ (pi*U * ((1+((x^ 2) / U)) ^ (P + 1))))
return(result)
}
lognormal <- function(x, par) {
log.a <- par[1]
σ <- exp(par[2])
N <- par[3]
result <- N * exp(-(log(x)-log.a)^2 / (2*σ^2)) / (x^2 * 2*pi * sqrt(2*pi*σ^2))
return(result)
}
S.functions <- function(x, par, fun){
fun <- match.arg(fun,
c("Clark2dt",
"lognormal"))
f <- get(fun)
result <- f(x, par)
return(result)
}
S.functions(x = 1, par =1:3, fun = "C")
S.functions(x = 1, par =1:3, fun = "l")
devtools::document()
devtools::document()
devtools::document()
devtools::document()
w <- tau - 0.5 + 0.5*sign(res)
S <- function(y, x, par, tau, fun) {
res <- y - S.functions(x, par, fun)
w <- tau - 0.5 + 0.5*sign(res)
sum(x^0 * w * res, na.rm=TRUE)
}
S(y = 1, x = 1, par = 1:3, tau = 0.99, fun fun = "l")
S(y = 1, x = 1, par = 1:3, tau = 0.99,  fun = "l")
devtools::load_all()
?S
devtools::load_all()
?S
help(package = "mgcv")
S <- function(y, x, par, tau, fun) {
res <- y - S.functions(x, par, fun)
w <- tau - 0.5 + 0.5*sign(res)
sum(x^0 * w * res, na.rm=TRUE)
}
devtools::load_all()
S.functions()
S.functions
devtools::load_all()
?quaxNat
?S
?S.function
?s.function
?s.functions
?lognormal
S <- function(y, x, par, tau, fun) {
res <- y - S.functions(x, par, fun)
w <- tau - 0.5 + 0.5*sign(res)
sum(x^0 * w * res, na.rm=TRUE)
}
devtools::load_all()
S?
?S
devtools::load_all()
?S
devtools::load_all()
?S
devtools::load_all()
?S
devtools::load_all()
?S
?Lognormal
source("~/quaxNat/R/qr.R", encoding = 'UTF-8')
devtools::load_all()
?Lognormal
source("~/quaxNat/R/objective function for minimization.R", encoding = 'UTF-8')
devtools::load_all()
?S
devtools::load_all()
library(quaxNat)
?S
library(quaxNat)
?S
source("~/quaxNat/R/objective function for minimization.R", encoding = 'UTF-8')
library(quaxNat)
?S
library(quaxNat)
devtools::load_all()
library(quaxNat)
S(y = 1,  x = 1, par = 1:3, tau = 0.99,  fun = "l")
#' optN
#'
#' @param
#'
#'
#'
#'
#'
#'
#'
optN <- function(par) {
y <- S(c(par, 0))
Nmax <- 1000000; while (S(c(par, Nmax)) < y) Nmax <- 100*Nmax
optimize(function(N) S(c(par, N)), c(0, Nmax), tol=1e-50)
}
optN(par = 1)
optN(par = 1, fun = "l")
optN(par = 1:3, fun = "l")
optN(par = 1:3, fun = "lognormal")
32-7
31-7
#' optN
#'
#' @inheritParams S
#'
#'
optN <- function(par,x, y, tau, fun,
Nmax = 1000000) {
y <- S(x = x,
y = y,
tau = tau,
par = c(par, 0),
fun = fun)
while (S(x = x,
y = y,
tau = tau,
par = c(par, Nmax),
fun = fun) < y) { # muss ich jetzt hier den ganzen Bumms eintragen? (x, y, par, tau, fun)
Nmax <- 100*Nmax
}
optimize(function(N) S(x = x,
y = y,
tau = tau,
par = c(par, N),
fun = fun),
c(0, Nmax),
tol=1e-50) # muss ich jetzt hier den ganzen Bumms eintragen? (x, y, par, tau, fun)
}
optN(par = 1:3, x = 1, y = 1, tau = 0.9, fun = "Clark2dt")
library(quaxNat)
?optN
?optN
devtools::load_all()
?optN
devtools::load_all()
?optN
?optN
library(quaxNat)
?quaxNat
' Distmap
#'
#' @details A distance map is created for the study area.
#'
#' @return what is returned by the function?
#' @param fe_raster Remote sensing raster dataset with tree species classification of specific tree species and tree species groups.
#' @param fe_polygon Geodata set representing the study area. This can be a polygon or point dataset. This describes the outer boundary of the study area. A buffer of 1000 m is placed around the Bbox to possibly take into account seed trees outside the study area
#' @param treespecies Represents the numerical value by which the tree species of interest was encoded in the raster dataset.
#'
Distmap <- function(fe_raster, fe_polygon, treespecies){
window <- segregate(terra::crop(fe_raster, sf::st_buffer(st_union(fe_polygon), dist = 1000)))[[treespecies]]
distmap <- terra::distance(window, target = 0)
return(distmap)
}
?Distmap
library(quaxNat)
?Distmap
library(quaxNat)
?Distmap
?Distmap
library(quaxNat)
?Distmap
?Distmap
?Distmap
library(quaxNat)
?Distmap
library(quaxNat)
?Distmap
library(quaxNat)
?Distmap
library(quaxNat)
?Distmap
library(quaxNat)
?extract_dist
library(quaxNat)
setwd("C:/Users/maxer/Downloads" )
VJ_pot <- read.csv2("VJ_pot.csv", fileEncoding="latin1")
str(VJ_pot)
plot(VJ_pot$distance_dgl, VJ_pot$Dgl_B0 * 10000/(pi/4*6^2),
xlab = "Distanz zur nächsten Douglasie [m]",
ylab = "Verjüngungsdichte Douglasie B0 [N/ha]",
ylim = c(0,11000), xlim = c(0,700))
x <- VJ_pot$distance_dgl
y <- VJ_pot$Dgl_B0* 10000/(3^2*pi)
library(quaxNat)
x <- VJ_pot$distance_dgl
y <- VJ_pot$Dgl_B0* 10000/(3^2*pi)
fun <- Clark2dt
install.packages("quaxNat")
install.packages("quaxNat")
#' Clark2DT-Function
#'
#' @details details to your function
#'
#' @return what is returned by the function?
#'
#' @param par parameters U, P, N estimated within the Clark2DT function
#' @param x represents the distance to the nearest seed source. Must be numeric
#'
#' @details Mixture of Gaussian nuclei that produces tails that are not quite as long. Maximum at seed tree itself and cannot become 0 at x = 0.
Clark2dt <- function(x, par){
U <- par[1]
P <- par[2]
N <- par[3]
result <- N * ((P)/ (pi*U * ((1+((x^ 2) / U)) ^ (P + 1))))
return(result)
}
lognormal <- function(x, par) {
log.a <- par[1]
σ <- exp(par[2])
N <- par[3]
result <- N * exp(-(log(x)-log.a)^2 / (2*σ^2)) / (x^2 * 2*pi * sqrt(2*pi*σ^2))
return(result)
}
S <- function(x, y, par, tau, fun) {
res <- y - fun(x, par)
w <- tau - 0.5 + 0.5*sign(res)
result <- sum(x^0 * w * res, na.rm=TRUE)
return(result)
}
#' optN
#' @description  For given a,σ the global minimum in N can always be found with any desired precision, usually in a small number of steps, by successively shrinking an interval. We realize this as an inner, nested minimization in the function optN.
#'
#'
#' @inheritParams S
#'
#'
optN <- function(x, y, tau, fun,par,
Nmax = 1000000) {
y <- S(x = x,
y = y,
tau = tau,
par = c(par, 0),
fun = fun)
while (S(x = x,
y = y,
tau = tau,
par = c(par, Nmax),
fun = fun) < s) { # muss ich jetzt hier den ganzen Bumms eintragen? (x, y, par, tau, fun)
Nmax <- 100*Nmax
}
optimize(function(N) S(x = x,
y = y,
tau = tau,
par = c(par, N),
fun = fun),
c(0, Nmax),
tol=1e-50) # muss ich jetzt hier den ganzen Bumms eintragen? (x, y, par, tau, fun)
}
#'SN
#' @inheritParams optN
#'
SN <- function(x, y, tau, fun,par, Nmax = 1000000) { # Search for the minimum of the reduced objective
o <- optN(x, y, tau, fun,par, Nmax = 1000000)$objective
o$objective
}
quax <-  function(x, y, tau, fun) {
optim(c(8, 1), SN, x = x, y = y, tau = tau, fun = fun, control=list(reltol=0))
}
fun <- Clark2dt
o <- quax(x, y, tau, fun)
tau <- 0.9998
tau
tau <- 0.9998
x <- VJ_pot$distance_dgl
y <- VJ_pot$Dgl_B0* 10000/(3^2*pi)
fun <- Clark2dt
o <- quax(x, y, tau, fun)
o <- quax(x, y, tau, fun)
quax <-  function(x, y, tau, fun=lognormal) {
optim(c(8, 1), SN, x = x, y = y, tau = tau, fun = fun, control=list(reltol=0))
}
quax <-  function(x, y, tau, fun=lognormal) {
optim(c(8, 1), SN, x = x, y = y, tau = tau, fun = fun, control=list(reltol=0))
}
o <- quax(x, y, tau, fun)
#' optN
#' @description  For given a,σ the global minimum in N can always be found with any desired precision, usually in a small number of steps, by successively shrinking an interval. We realize this as an inner, nested minimization in the function optN.
#'
#'
#' @inheritParams S
#'
#'
optN <- function(x, y, tau, fun,par,
Nmax = 1000000) {
s <- S(x = x,
y = y,
tau = tau,
par = c(par, 0),
fun = fun)
while (S(x = x,
y = y,
tau = tau,
par = c(par, Nmax),
fun = fun) < s) { # muss ich jetzt hier den ganzen Bumms eintragen? (x, y, par, tau, fun)
Nmax <- 100*Nmax
}
optimize(function(N) S(x = x,
y = y,
tau = tau,
par = c(par, N),
fun = fun),
c(0, Nmax),
tol=1e-50) # muss ich jetzt hier den ganzen Bumms eintragen? (x, y, par, tau, fun)
}
#'SN
#' @inheritParams optN
#'
SN <- function(x, y, tau, fun,par, Nmax = 1000000) { # Search for the minimum of the reduced objective
o <- optN(x, y, tau, fun,par, Nmax = 1000000)$objective
o$objective
}
quax <-  function(x, y, tau, fun) {
optim(c(8, 1), SN, x = x, y = y, tau = tau, fun = fun, control=list(reltol=0))
}
o <- quax(x, y, tau, fun)
#' optN
#' @description  For given a,σ the global minimum in N can always be found with any desired precision, usually in a small number of steps, by successively shrinking an interval. We realize this as an inner, nested minimization in the function optN.
#'
#'
#' @inheritParams S
#'
#'
optN <- function(x, y, tau, fun,par,
Nmax = 1000000) {
s <- S(x = x,
y = y,
tau = tau,
par = c(par, 0),
fun = fun)
while (S(x = x,
y = y,
tau = tau,
par = c(par, Nmax),
fun = fun) < s) { # muss ich jetzt hier den ganzen Bumms eintragen? (x, y, par, tau, fun)
Nmax <- 100*Nmax
}
optimize(function(N) S(x = x,
y = y,
tau = tau,
par = c(par, N),
fun = fun),
c(0, Nmax),
tol=1e-50) # muss ich jetzt hier den ganzen Bumms eintragen? (x, y, par, tau, fun)
}
#'SN
#' @inheritParams optN
#'
SN <- function(x, y, tau, fun,par, Nmax = 1000000) { # Search for the minimum of the reduced objective
o <- optN(x, y, tau, fun,par, Nmax = 1000000)$objective
o$objective
}
quax <-  function(x, y, tau, fun) {
optim(c(8, 1), SN, x = x, y = y, tau = tau, fun = fun, control=list(reltol=0))
}
o <- quax(x, y, tau, fun)
quax <-  function(x, y, tau, fun=lognormal) {
optim(c(8, 1), SN, x = x, y = y, tau = tau, fun = fun, control=list(reltol=0))
}
o <- quax(x, y, tau, fun)
S <- function(x, y, par, tau, fun) {
res <- y - fun(x, par)
w <- tau - 0.5 + 0.5*sign(res)
result <- sum(x^0 * w * res, na.rm=TRUE)
return(result)
}
#' optN
#' @description  For given a,σ the global minimum in N can always be found with any desired precision, usually in a small number of steps, by successively shrinking an interval. We realize this as an inner, nested minimization in the function optN.
#'
#'
#' @inheritParams S
#'
#'
optN <- function(x, y, tau, fun,par,
Nmax = 1000000) {
s <- S(x = x,
y = y,
tau = tau,
par = c(par, 0),
fun = fun)
while (S(x = x,
y = y,
tau = tau,
par = c(par, Nmax),
fun = fun) < s) { # muss ich jetzt hier den ganzen Bumms eintragen? (x, y, par, tau, fun)
Nmax <- 100*Nmax
}
optimize(function(N) S(x = x,
y = y,
tau = tau,
par = c(par, N),
fun = fun),
c(0, Nmax),
tol=1e-50) # muss ich jetzt hier den ganzen Bumms eintragen? (x, y, par, tau, fun)
}
#'SN
#' @inheritParams optN
#'
SN <- function(x, y, tau, fun,par, Nmax = 1000000) { # Search for the minimum of the reduced objective
o <- optN(x, y, tau, fun,par, Nmax = 1000000)
cat("par =", par, "objective =", o$objective, "N =", o$minimum, "\n"); flush.console()
o$objective
}
quax <-  function(x, y, tau, fun=lognormal) {
optim(c(8, 1), SN, x = x, y = y, tau = tau, fun = fun, control=list(reltol=0))
}
o <- quax(x, y, tau, fun)
o
print(o$value, 20)
o
N <- optN(x, y, tau, fun, o$par)$minimum
cat("Parameter estimates:\n",
"N =", N, "\n",
"a =", exp(o$par[1]),"m\n",
"?? =", exp(o$par[2]), "\n",
"f(100 m) =", fun(100, c(o$par, N)), "\n"
)
plot(y~x, cex=0.5, xlim = c(0,800))
curve(fun(x, c(o$par, N)), add=TRUE, n=1001, col="red", lty = 1, lwd = 2)
install.packages("quaxNat")
library(quaxNat)
ßquaxNat::quax
?quaxNat::quax
setwd("C:/Users/maxer/Downloads" )
VJ_pot <- read.csv2("VJ_pot.csv", fileEncoding="latin1")
str(VJ_pot)
plot(VJ_pot$distance_dgl, VJ_pot$Dgl_B0 * 10000/(pi/4*6^2),
xlab = "Distanz zur nächsten Douglasie [m]",
ylab = "Verjüngungsdichte Douglasie B0 [N/ha]",
ylim = c(0,11000), xlim = c(0,700))
tau <- 0.9998
x <- VJ_pot$distance_dgl
y <- VJ_pot$Dgl_B0* 10000/(3^2*pi)
fun <- Clark2dt
fun <- quaxNat::Clark2dt
quaxNat::Clark2DT
?quaxNat::S.functions
?quaxNat::S.functions
library(quaxNat)
fun <- Clark2dt
o <- quax(x, y, tau, fun = Clark2dt)
library(quax)
library(quaxNat)
o <- quax(x, y, tau, fun = Clark2dt)
o <- quaxNat::quax(x, y, tau, fun = Clark2dt)
library(quaxNat)
?quaxNat::quax
quaxNat::quax(x,y)
detach("package:quaxNat", unload = TRUE)
library(quaxNat)
quaxNat::quax(x,y)
?quaxNat::extract_dist
?quaxNat::Clark2dt
library(quaxNat)
?quaxNat::quax
library(quaxNat)
?quaxNat::quax
quax <-  function(x, y, tau, fun=lognormal) {
optim(c(8, 1), SN, x = x, y = y, tau = tau, fun = fun, control=list(reltol=0))
}
library(quaxNat)
?quaxNat::quax
library(quaxNat)
?quaxNat::quax
library(quaxNat)
cd existing_repo
extract_dist <- function(fe_raster, fe_geom, treespecies){
extract <- terra::extract(Distmap(fe_raster, fe_geom, treespecies), fe_geom)[,2]
return(extract)
}
