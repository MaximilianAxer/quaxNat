<!DOCTYPE html><html><head><title>R: Estimating Potential Regeneration Densities by Quantile...</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R.css" />
</head><body><div class="container">

<table style="width: 100%;"><tr><td>quax</td><td style="text-align: right;">R Documentation</td></tr></table>

<h2 id='quax'>Estimating Potential Regeneration Densities by Quantile Regression</h2>

<h3>Description</h3>

<p><code>quax</code> estimates parameters of a spatial dispersal kernel that describes
the regeneration potential as the <code class="reqn">\tau </code>th quantile of the regeneration
density. Here <code class="reqn">\tau </code> is between 0 and 1, with typical values close to 1
representing the situation that the full regeneration potential is realized
only at a small fraction of all sites.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>quax(...)

## Default S3 method:
quax(
  ...,
  y,
  tau,
  fun = k_lognormal,
  dim = 2,
  weights = 1,
  par = c(log.a = 8, log.b = 1),
  tol = 1e-50
)

## S3 method for class 'formula'
quax(
  formula,
  data,
  tau,
  fun = k_lognormal,
  subset,
  weights,
  na.action,
  offset,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="quax_:_...">...</code></td>
<td>
<p>Vector of positions <code class="reqn">x_{1},...,x_{n}</code> or distances to the
seed source as expected by the specific dispersal kernel. Optionally,
further arguments passed to <code>optim</code> (see Details).</p>
</td></tr>
<tr><td><code id="quax_:_y">y</code></td>
<td>
<p>Observed values <code class="reqn">y_{1},...,y_{n}</code> of the regeneration density
of the inventory plot.</p>
</td></tr>
<tr><td><code id="quax_:_tau">tau</code></td>
<td>
<p>Numeric between 0 and 1. Specifies the quantile <code class="reqn">\tau </code>
used for the quantile regression.</p>
</td></tr>
<tr><td><code id="quax_:_fun">fun</code></td>
<td>
<p>Dispersal kernel <code class="reqn">k_{\theta }</code> assumed for the regeneration
potential. Values allowed are <code>k_lognormal</code>, <code>k_t</code>, <code>k_power</code>,
<code>k_weibull</code>, <code>k_exponential.power</code> or a custom function (see Examples).
The default, <code>k_lognormal</code>, is to fit a model with log-normal distance
distributions.</p>
</td></tr>
<tr><td><code id="quax_:_weights">weights</code></td>
<td>
<p>Numeric vector of optional nonnegative weights <code class="reqn">w_i</code> of
the observations in the estimation procedure. Default is 1.</p>
</td></tr>
<tr><td><code id="quax_:_par">par</code></td>
<td>
<p>Numeric vector of initial values for the parameter vector
<code class="reqn">\theta </code>.</p>
</td></tr>
<tr><td><code id="quax_:_tol">tol</code></td>
<td>
<p>The desired accuracy for the inner optimization (see Details).</p>
</td></tr>
<tr><td><code id="quax_:_formula">formula</code></td>
<td>
<p>A formula of the form <code>y ~ x</code>.</p>
</td></tr>
<tr><td><code id="quax_:_data">data</code>, <code id="quax_:_subset">subset</code>, <code id="quax_:_na.action">na.action</code>, <code id="quax_:_offset">offset</code></td>
<td>
<p>For the formula interface:
Further arguments passed to <code>model.frame</code> (along with <code>weights</code>).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function estimates the parameters <code class="reqn">N</code> and <code class="reqn">\theta </code>
of the regeneration potential <code class="reqn">Nk_{\theta }</code> by minimizing
</p>
<p style="text-align: center;"><code class="reqn">\displaystyle \sum _{i=1}^{n}w_{i}(y_{i}-Nk_{\theta }(x_{i}))\bigl\{
  \begin{smallmatrix}\tau \hphantom{-1} &amp;\text{if }y_{i}&gt;Nk_{\theta }
  (x_{i})\\ \tau -1&amp;\text{if not}\hphantom{.............}\end{smallmatrix}</code>
</p>

<p>(see e.g. ??FAHRMEIER ...). Due to convexity the minimum in <code class="reqn">N</code> for
a given vector <code class="reqn">\theta </code> can always be found by successively shrinking
an interval; this is implemented in an inner, nested minimization using
<code>optimize</code>, the result which is minimized in
<code class="reqn">\theta </code> using <code>optim</code>.
</p>


<h3>Value</h3>

<p>The estimated function, including an attribute <code>o</code> containing the
results of <code>optim</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Prepare artificial example data:
set.seed(0)
r &lt;- rgamma(200, shape=2, scale=150)
simulated.data &lt;- data.frame(distance = r, density =
  rpois(length(r), k_lognormal(r, par=c(6,0), N=1000000, d=2)))
plot(density ~ distance, simulated.data)

## Run quax function:
f1 &lt;- quax(x = simulated.data$distance, y = simulated.data$density,
  tau = 0.9, fun = k_lognormal)
summary(f1)
curve(f1(x), add=TRUE)

## Do the same using formula interface:
f1 &lt;- quax(density ~ distance, simulated.data,
  tau = 0.9, fun = k_lognormal)
summary(f1)

## Use another quantile:
f2 &lt;- quax(density ~ distance, simulated.data,
  tau = 0.99, fun = k_lognormal)
summary(f2)
curve(f2(x), add=TRUE, lwd=0)

## Show effect of weights:
f3 &lt;- quax(density ~ distance, simulated.data,
  tau = 0.9, fun = k_lognormal, weights = distance)
summary(f3)
curve(f3(x), add=TRUE, lty=3)

## Compare various dispersal models:
fun &lt;- c("k_lognormal","k_t","k_weibull","k_power","k_exponential.power")
for (i in seq_along(fun))
  curve(quax(density ~ distance, simulated.data,
    tau = 0.9, fun = get(fun[i]), weights = distance)(x),
    add=TRUE, col=i, lty=3)
legend("topright", fun, col=seq_along(fun), lty=3)

## Use positions in computation:
simulated.data$position &lt;- r *
  (\(a) cbind(cos(a),sin(a))) (rnorm(length(r)))
f3 &lt;- quax(density ~ position, simulated.data,
  tau = 0.9, fun = k_lognormal, weights = distance)
summary(f3)

## Use custom variant of lognormal model that includes a shift:
plot(simulated.data$position)
f4 &lt;- quax(density ~ position, simulated.data,
  tau = 0.9, par = c(8, 1, 0, 0),
  fun = function(x, par, N, d)
    k_lognormal(x - rep(par[-(1:2)],each=NROW(x)), par[1:2], N, d)
)
summary(f4)
</code></pre>


</div>
</body></html>
