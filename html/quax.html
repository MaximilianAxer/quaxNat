<!DOCTYPE html><html><head><title>R: Estimating Potential Regeneration Densities by Quantile...</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R.css" />
</head><body><div class="container">

<table style="width: 100%;"><tr><td>quax</td><td style="text-align: right;">R Documentation</td></tr></table>

<h2 id='quax'>Estimating Potential Regeneration Densities by Quantile Regression</h2>

<h3>Description</h3>

<p><code>quax</code> estimates parameters of a spatial dispersal kernel that describes the potential regeneration density.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>quax(...)

## Default S3 method:
quax(
  ...,
  y,
  tau,
  fun = k_lognormal,
  dim = 2,
  weights = 1,
  par = c(log.a = 8, log.b = 1),
  tol = 1e-50
)

## S3 method for class 'formula'
quax(
  formula,
  data,
  tau,
  fun = k_lognormal,
  subset,
  weights,
  na.action,
  offset,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="quax_:_...">...</code></td>
<td>
<p>Further arguments passed to <code>optim</code>.</p>
</td></tr>
<tr><td><code id="quax_:_y">y</code></td>
<td>
<p>Observed regeneration density of the inventory plot.</p>
</td></tr>
<tr><td><code id="quax_:_tau">tau</code></td>
<td>
<p>Numeric between 0 and 1. Specifies the quantile used for the quantile regression.</p>
</td></tr>
<tr><td><code id="quax_:_fun">fun</code></td>
<td>
<p>Function assumed for the quantile regression of the regeneration potential. Values allowed are <code>k_lognormal</code>, <code>k_t</code>, <code>k_power</code>, <code>k_weibull</code>, <code>k_exponential.power</code> or a custom function. The default is to fit a lognormal model.</p>
</td></tr>
<tr><td><code id="quax_:_weights">weights</code></td>
<td>
<p>Numeric vector of weights of the observations in the estimation procedure. Default is 0.</p>
</td></tr>
<tr><td><code id="quax_:_par">par</code></td>
<td>
<p>Numeric vector of initial values for the parameters to be optimized over, exluding the first parameter <code>N</code>.</p>
</td></tr>
<tr><td><code id="quax_:_tol">tol</code></td>
<td>
<p>The desired accuracy for the inner optimization, see <code>optimize</code>.</p>
</td></tr>
<tr><td><code id="quax_:_formula">formula</code></td>
<td>
<p>A formula of the form <code>y ~ x</code>.</p>
</td></tr>
<tr><td><code id="quax_:_data">data</code>, <code id="quax_:_subset">subset</code>, <code id="quax_:_weights">weights</code>, <code id="quax_:_na.action">na.action</code>, <code id="quax_:_offset">offset</code></td>
<td>
<p>For the formula interface: Further arguments passed to <code>model.frame</code> (along with <code>weights</code>).</p>
</td></tr>
<tr><td><code id="quax_:_x">x</code></td>
<td>
<p>Numeric vector giving the distance to the nearest seed source for the inventory plot.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function return a list including the estimated parameters for the quantile regression for the specific distribution function. ... The global minimum in <code class="reqn">N</code> for given other parameters can always be found with any desired precision, usually in a small number of steps, by successively shrinking an interval. We realize this as an inner, nested minimization in an internal function <code>optN</code>.
</p>


<h3>Value</h3>

<p>The estimated function, including an attribute <code>o</code> containing the results of <code>optim</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Create data frame (artificial):
r &lt;- rlnorm(200, meanlog = 5, sdlog = 1)
simulated.data &lt;- data.frame(distance = r, density =
  rpois(length(r), k_lognormal(r, par=c(log(5),log(1)), N=2000)))

## Run quax function:
f &lt;- quax(x = simulated.data$distance, y = simulated.data$density,
  tau = 0.9, fun = k_lognormal)
summary(f)

## Do the same with the formula interface:
f &lt;- quax(density ~ distance, simulated.data,
  tau = 0.9, fun = k_lognormal)
plot(density ~ distance, simulated.data)
curve(f(x), add=TRUE)

## Show effect of weights:
fw &lt;- quax(density ~ distance, simulated.data,
  tau = 0.9, fun = k_lognormal, weights = distance)
summary(fw)
curve(fw(x), add=TRUE, col="green", lty=3)
</code></pre>


</div>
</body></html>
