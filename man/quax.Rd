% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/quax.R
\name{quax}
\alias{quax}
\alias{quax.default}
\alias{quax.formula}
\title{Estimating Potential Regeneration Densities by Quantile Regression}
\usage{
quax(...)

\method{quax}{default}(
  ...,
  y,
  tau,
  fun = k_lognormal,
  dim = 2,
  weights = 1,
  par = c(log.a = 8, log.b = 1),
  tol = 1e-50
)

\method{quax}{formula}(
  formula,
  data,
  tau,
  fun = k_lognormal,
  subset,
  weights,
  na.action,
  offset,
  ...
)
}
\arguments{
\item{...}{Vector of positions \eqn{x_{1},...,x_{n}} or distances to the
seed source as required by the specific dispersal kernel. Optionally,
further arguments passed to \code{optim} (see Details).}

\item{y}{Observed values \eqn{y_{1},...,y_{n}} of the regeneration density
of the inventory plot.}

\item{tau}{Numeric between 0 and 1. Specifies the quantile \eqn{\tau }
used for the quantile regression.}

\item{fun}{Dispersal kernel \eqn{k_{\theta }} assumed for the regeneration
potential. Values allowed are \code{k_lognormal}, \code{k_t}, \code{k_power},
\code{k_weibull}, \code{k_exponential.power} or a custom function (see Examples).
The default, \code{k_lognormal}, is to fit a model with log-normal distance
distributions.}

\item{weights}{Numeric vector of optional nonnegative weights \eqn{w_i} of
the observations in the estimation procedure. Default is 1.}

\item{par}{Numeric vector of initial values for the parameter vector
\eqn{\theta }.}

\item{tol}{The desired accuracy for the inner optimization (see Details).}

\item{formula}{A formula of the form \code{y ~ x}.}

\item{data, subset, na.action, offset}{For the formula interface:
Further arguments passed to \code{model.frame} (along with \code{weights}).}
}
\value{
The estimated function, including an attribute \code{o} containing the
results of \code{optim}.
}
\description{
\code{quax} estimates parameters of a spatial dispersal kernel that describes
the regeneration potential as the \eqn{\tau }th quantile of the
regeneration density. Here \eqn{\tau } is between 0 and 1, with typical
values close to 1 representing the situation that the full regeneration
potential is realized only at a small fraction of all sites.
}
\details{
The function estimates the parameters \eqn{N} and \eqn{\theta }
of the regeneration potential \eqn{Nk_{\theta }} by minimizing
\deqn{\displaystyle \sum _{i=1}^{n}w_{i}(y_{i}-Nk_{\theta }(x_{i}))\bigl\{
  \begin{smallmatrix}\tau \hphantom{-1} &\text{if }y_{i}>Nk_{\theta }
  (x_{i})\\ \tau -1&\text{if not}\hphantom{.............}\end{smallmatrix}}
(Koenker and Bassett 1978). Due to convexity the minimum in \eqn{N} for a
given vector \eqn{\theta } can always be found by successively shrinking
an interval; this is implemented in an inner, nested minimization using
\code{\link[stats:optimize]{optimize}}, the result which is minimized in
\eqn{\theta } using \code{\link[stats:optim]{optim}}.
}
\examples{
## Prepare artificial example data:
set.seed(0)
r <- rgamma(200, shape=2, scale=150)
simulated.data <- data.frame(distance = r, density =
  rpois(length(r), k_lognormal(r, par=c(6,0), N=1000000, d=2)))
plot(density ~ distance, simulated.data)

## Run quax function:
f1 <- quax(x = simulated.data$distance, y = simulated.data$density,
  tau = 0.9, fun = k_lognormal)
summary(f1)
curve(f1(x), add=TRUE)

## Do the same using formula interface:
f1 <- quax(density ~ distance, simulated.data,
  tau = 0.9, fun = k_lognormal)
summary(f1)

## Use another quantile:
f2 <- quax(density ~ distance, simulated.data,
  tau = 0.99, fun = k_lognormal)
summary(f2)
curve(f2(x), add=TRUE, lwd=0)

## Show effect of weights:
f3 <- quax(density ~ distance, simulated.data,
  tau = 0.9, fun = k_lognormal, weights = distance)
summary(f3)
curve(f3(x), add=TRUE, lty=3)

## Compare various dispersal models:
fun <- c("k_lognormal","k_t","k_weibull","k_power","k_exponential.power")
for (i in seq_along(fun))
  curve(quax(density ~ distance, simulated.data,
    tau = 0.9, fun = get(fun[i]), weights = distance)(x),
    add=TRUE, col=i, lty=3)
legend("topright", fun, col=seq_along(fun), lty=3)

## Use positions in computation:
simulated.data$position <- r *
  (\(a) cbind(cos(a),sin(a))) (rnorm(length(r)))
f3 <- quax(density ~ position, simulated.data,
  tau = 0.9, fun = k_lognormal, weights = distance)
summary(f3)

## Use custom variant of lognormal model that includes a shift:
plot(simulated.data$position)
f4 <- quax(density ~ position, simulated.data,
  tau = 0.9, par = c(8, 1, 0, 0),
  fun = function(x, par, N, d)
    k_lognormal(x - rep(par[-(1:2)],each=NROW(x)), par[1:2], N, d)
)
summary(f4)

}
\references{
Koenker, R., Bassett, G. (1978). Regression Quantiles. \emph{Econometrica}
\strong{46(1)}, 33â€“50.
\doi{10.2307/1913643}
}
