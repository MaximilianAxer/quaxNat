% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/optN.R
\name{quax}
\alias{quax}
\alias{quax.default}
\alias{quax.formula}
\title{Estimating Potential Regeneration Densities by Quantile Regression}
\usage{
quax(...)

\method{quax}{default}(
  ...,
  y,
  tau,
  fun = k_lognormal,
  dim = 2,
  weights = 1,
  par = c(log.a = 8, log.b = 1),
  tol = 1e-50
)

\method{quax}{formula}(
  formula,
  data,
  tau,
  fun = k_lognormal,
  subset,
  weights,
  na.action,
  offset,
  ...
)
}
\arguments{
\item{...}{Further arguments passed to \code{optim}.}

\item{y}{Observed regeneration density of the inventory plot.}

\item{tau}{Numeric between 0 and 1. Specifies the quantile used for the quantile regression.}

\item{fun}{Function assumed for the quantile regression of the regeneration potential. Values allowed are \code{k_lognormal}, \code{k_t}, \code{k_power}, \code{k_weibull}, \code{k_exponential.power} or a custom function. The default is to fit a lognormal model.}

\item{weights}{Numeric vector of weights of the observations in the estimation procedure. Default is 0.}

\item{par}{Numeric vector of initial values for the parameters to be optimized over, exluding the first parameter \code{N}.}

\item{tol}{The desired accuracy for the inner optimization, see \code{optimize}.}

\item{formula}{A formula of the form \code{y ~ x}.}

\item{data, subset, weights, na.action, offset}{For the formula interface: Further arguments passed to \code{model.frame} (along with \code{weights}).}

\item{x}{Numeric vector giving the distance to the nearest seed source for the inventory plot.}
}
\value{
The estimated function, including an attribute \code{o} containing the results of \code{optim}.
}
\description{
\code{quax} estimates parameters of a spatial dispersal kernel that describes the potential regeneration density.
}
\details{
The function return a list including the estimated parameters for the quantile regression for the specific distribution function. ... The global minimum in \eqn{N} for given other parameters can always be found with any desired precision, usually in a small number of steps, by successively shrinking an interval. We realize this as an inner, nested minimization in an internal function \code{optN}.
}
\examples{
## Create data frame (artificial):
r <- rlnorm(200, meanlog = 5, sdlog = 1)
simulated.data <- data.frame(distance = r, density =
  rpois(length(r), k_lognormal(r, par=c(log(5),log(1)), N=2000, d=2)))

## Run quax function:
f1 <- quax(x = simulated.data$distance, y = simulated.data$density,
  tau = 0.9, fun = k_lognormal)
summary(f1)

## Do the same using formula interface:
f1 <- quax(density ~ distance, simulated.data,
  tau = 0.9, fun = k_lognormal)
summary(f1)
plot(density ~ distance, simulated.data)
curve(f1(x), add=TRUE)

## Show effect of weights:
f2 <- quax(density ~ distance, simulated.data,
  tau = 0.9, fun = k_lognormal, weights = distance)
summary(f2)
curve(f2(x), add=TRUE, col="green", lty=3)

## Use positions in computation:
simulated.data$position <- r *
  (\(a) cbind(cos(a),sin(a))) (runif(length(r),0,2*pi))
f2 <- quax(density ~ position, simulated.data,
  tau = 0.9, fun = k_lognormal, weights = distance)
summary(f2)

## Use custom variant of lognormal model that includes a shift:
plot(simulated.data$position)
f3 <- quax(density ~ position, simulated.data,
  tau = 0.9, par = c(8, 1, 0, 0),
  fun = function(x, par, N=1, d=NCOL(x)) {
    x[,1] <- x[,1] - par[3]
    x[,2] <- x[,2] - par[4]
    r <- rownorms(x)
    log.a <- par[1]
    σ <- exp(par[2])
    N / surface(d,r) * dlnorm(r,log.a,σ)
  }
)
summary(f3)
}
